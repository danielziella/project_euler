#!/usr/bin/python3
# -*- encoding: utf-8 -*-


import functools
import heapq
from . import helpers
import itertools
import math
import operator
import pkg_resources


def problem1():
    """If we list all the natural numbers below 10 that are multiples of 3 or
    5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of
    all the multiples of 3 or 5 below 1000."""
    return sum(x for x in range(1000) if (x % 3 == 0) or (x % 5 == 0))


def problem2():
    """Each new term in the Fibonacci sequence is generated by adding the
    previous two terms. By starting with 1 and 2, the first 10 terms will be:
        1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    By considering the terms in the Fibonacci sequence whose values do not
    exceed four million, find the sum of the even-valued terms."""

    def fn_generator(limit):
        previous = 1
        current = 1
        while current < limit:
            yield current
            previous, current = current, previous+current

    return sum(x for x in fn_generator(4000000) if x % 2 == 0)


def problem3():
    """The prime factors of 13195 are 5, 7, 13 and 29.
    What is the largest prime factor of the number 600851475143 ?"""

    n = 600851475143
    m = 2

    while m < n:
        while n % m == 0:
            n = n // m
        m = m+1
    return n


def problem4():
    """A palindromic number reads the same both ways. The largest palindrome
    made from the product of two 2-digit numbers is 9009 = 91 × 99. Find the
    largest palindrome made from the product of two 3-digit numbers."""

    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    left, right = 999, 999
    product = -left*right
    h = []
    s = set()

    while not is_palindrome(-product):
        product = -(left-1)*right
        if product not in s:
            heapq.heappush(h, (product, left-1, right))
            s.add(product)
        product = -left*(right-1)
        if product not in s:
            heapq.heappush(h, (product, left, right-1))
            s.add(product)
        product, left, right = heapq.heappop(h)

    return -product


def problem5():
    """2520 is the smallest number that can be divided by each of the numbers
    from 1 to 10 without any remainder. What is the smallest positive number
    that is evenly divisible by all of the numbers from 1 to 20?"""

    def lcm_generator():
        lcm = 1
        n = 0
        while True:
            n = n+1
            lcm = lcm*n//math.gcd(lcm, n)
            yield lcm
    return helpers.take_nth(lcm_generator(), 20)


def problem6():
    """The sum of the squares of the first ten natural numbers is,
    1^2 + 2^2 + ... + 10^2 = 385

    The square of the sum of the first ten natural numbers is,
    (1 + 2 + ... + 10)^2 = 55^2 = 3025

    Hence the difference between the sum of the squares of the first ten
    natural numbers and the square of the sum is 3025 − 385 = 2640.

    Find the difference between the sum of the squares of the first one hundred
    natural numbers and the square of the sum.

    return helpers.sum_integers(100)**2 - helpers.sum_squares(100)"""


def problem7():
    """
    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
    that the 6th prime is 13.
    What is the 10 001st prime number?"""

    return helpers.take_nth(helpers.prime_generator(), 10001)


def problem8():
    """The four adjacent digits in the 1000-digit number that have the greatest
    product are 9 × 9 × 8 × 9 = 5832.

    < resources/problem8.txt >

    Find the thirteen adjacent digits in the 1000-digit number that have the
    greatest product. What is the value of this product?"""

    astring = pkg_resources.resource_string('project_euler.resources',
                                            'problem8.txt') \
        .decode('utf-8').replace('\n', '')

    return max([functools.reduce(operator.mul, map(int, astring[k:k+13]))
                for k in range(len(astring))])


def problem9():
    """A Pythagorean triplet is a set of three natural numbers, a < b < c, for
    which,
        a^2 + b^2 = c^2

    For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

    There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    Find the product abc."""

    for a in range(1, 1000):
        for b in range(1, a+1):
            if a**2 + b**2 == (1000 - a - b)**2:
                return a*b*(1000 - a - b)


def problem10():
    """
    The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

    Find the sum of all the primes below two million.
    """
    return sum(itertools.takewhile(lambda x: x < 2000000,
                                   helpers.prime_generator()))


def problem11():
    """

    In the 20×20 grid below, four numbers along a diagonal line have been
    marked in red.

    < resources/problem11.txt >

    The product of these numbers is 26 × 63 × 78 × 14 = 1788696.

    What is the greatest product of four adjacent numbers in the same direction
    (up, down, left, right, or diagonally) in the 20×20 grid?
    """
    astring = pkg_resources.resource_string('project_euler.resources',
                                            'problem11.txt').decode('utf-8')
    grid = list(map(lambda x: list(map(int, x.split(' '))),
                    astring.strip().split('\n')))

    n = len(grid)  # 20x20 grid

    bestrow = max(functools.reduce(operator.mul, grid[i][j:j+4])
                  for i in range(n) for j in range(n-4))
    bestcol = max(functools.reduce(operator.mul,
                                   (grid[i+k][j] for k in range(4)))
                  for i in range(n-4) for j in range(n-4))
    bestdiag1 = max(functools.reduce(operator.mul,
                                     (grid[i+k][j+k] for k in range(4)))
                    for i in range(n-4) for j in range(n-4))
    bestdiag2 = max(functools.reduce(operator.mul,
                                     (grid[i+k][j+3-k] for k in range(4)))
                    for i in range(n-4) for j in range(n-4))
    return max(bestrow, bestcol, bestdiag1, bestdiag2)


def problem12():
    """The sequence of triangle numbers is generated by adding the natural
    numbers. So the 7th triangle number would be
    1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

    Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

    We can see that 28 is the first triangle number to have over five divisors.

    What is the value of the first triangle number to have over five hundred
    divisors?"""
    n = 1
    divisors = 1
    while divisors <= 500:
        n = n+1
        factorization = helpers.factorize(n)
        factorization.update(helpers.factorize(n+1))
        factorization[2] = factorization[2]-1
        divisors = functools.reduce(operator.mul,
                                    map(lambda x: x+1, factorization.values()))
    return n*(n+1)//2
